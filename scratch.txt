Using `new Function('...')` for fast compilation
BUT, how to make it safe and extend standard functionality?
-> Break expression down and then rebuild it into safe string

Expression('y = sum([x, 14 / 3, abs(-27), 5^2])').evaluate({ x: 13 });

=> new Function("state", "fn", "bi", "un", "state['y'] = fn['sum']([state['x'], 14 / 3, fn['abs'](fn[-](27)), 5^2]); return state;");
=> new Function("state", "fn", "bi", "un", "state['y'] = fn['sum']([state['x'], bi['/'](14, 3), fn['abs'](un['-'](27)), bi['^'](5, 2)]); return state;");

`state` has only "static" values and is passed in and out of function
`fn` holds all available functions so only allowed functions can be called
     (e.g. fn['eval'] is not available)
`bi` is for binary operations
`un` is for unary operations

http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm

The functions in `bi` and `un` could return a "compiled" string to reduce function calls during equation evaluation

Example:
bi['+'] = function (a, b) {
    return 'a + b';
}

This would most likely not introduce many improvements and may long-term slow function down since compiler can optimize frequent functions (i.e. add())
and may not be able to optimize if it's all in single function

Notes:
Set only works when it's working directly on the object
-> So passing in the current value and then overwriting it does not affect the original object
=> This generally doesn't matter except in cases of equality. Since attempting to make the equality operation generic, need to make accessing + updating state update state object

So, what are the cases for needing special equality operation?
-> Equation solving: Can be solved with rearranging into goal functions and wouldn't need to have equality dependence
==> Skip for now
